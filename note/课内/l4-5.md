# Lecture 4-5 Notes

* [Lecture 4-5 Notes](#lecture-4-5-notes)
  * [Binary Treeä¾‹å­](#binary-treeä¾‹å­)
  * [Generic Binary Treeï¼šä½¿ç”¨å‡½æ•°æŒ‡é’ˆä¾‹å­](#generic-binary-treeä½¿ç”¨å‡½æ•°æŒ‡é’ˆä¾‹å­)
  * [å¿«æ’ä¾‹å­](#å¿«æ’ä¾‹å­)
  * [Memory Management Challenges: æ‚¬ç©ºæŒ‡é’ˆ](#memory-management-challenges-æ‚¬ç©ºæŒ‡é’ˆ)
    * [Memory Leak å†…å­˜æ³„æ¼](#memory-leak-å†…å­˜æ³„æ¼)
    * [å¦‚ä½•é¿å…é‡æŒ‡é’ˆ&é€‰ç©ºæŒ‡é’ˆ](#å¦‚ä½•é¿å…é‡æŒ‡é’ˆé€‰ç©ºæŒ‡é’ˆ)
  * [Ownership: æ‰€æœ‰æƒ](#ownership-æ‰€æœ‰æƒ)
    * [Implementing RALL in C++](#implementing-rall-in-c)
    * [RALL: Resource management](#rall-resource-management)
    * [Modern Memory Management C++](#modern-memory-management-c)
  * [C++11 æ™ºèƒ½æŒ‡é’ˆ](#c11-æ™ºèƒ½æŒ‡é’ˆ)
  * [äºŒå‰æ ‘ï¼šæ™ºèƒ½æŒ‡é’ˆä¾‹å­](#äºŒå‰æ ‘æ™ºèƒ½æŒ‡é’ˆä¾‹å­)
  * [Ownership transfer](#ownership-transfer)

## Binary Treeä¾‹å­

```c
typedef struct node{
    const char* value;
    struct node* left;
    struct node* right;
}node;

// å»ºæ ‘
node* create_tree(sonst void* value, node* left, node* right)
{
    node* root = malloc(sizeof(node));//å¯¹ä¸­å¼€è¾Ÿï¼Œå¯ä»¥è¿”å›
    //åˆ†é…æˆåŠŸ
    if(root){
        root->value = value;
        root->left = left;
        root->right=right;
    }
    return root;
}

//æ¸…ç©ºæ ‘
void destroy_tree(node* root)
{
    if(root){
        destroy_tree(root->left);
        destroy_tree(root->right);
    }
    free(root);
}
int main(){
    node* root = create_tree("b", create_tree("a", NULL, NULL),
    create_tree("c", create_tree("d", NULL,NULL),
    create_tree("e", NULL,NULL)));
}

/*
     b
    / \
   a  c
    /  \
   d    e
 */

```

## Generic Binary Treeï¼šä½¿ç”¨å‡½æ•°æŒ‡é’ˆä¾‹å­

* æ¯ä¸ªèŠ‚ç‚¹å­˜çš„valueç±»å‹éšæ„
* **ä½¿ç”¨`void*`æ³›æŒ‡é’ˆ**

```c
struct node{
    const void* value_ptr;
    struct node* left;
    struct node* right;
}
// å¦‚ä½•è§£å¼•ï¼Ÿ
void print(node* root)
{
    if(root)
    {
        //å¦‚ä½•æ‰“å°æ¯ä¸ªnodeçš„value_ptræŒ‡é’ˆå­˜å‚¨çš„å€¼ï¼Ÿ
        print(root->left);
        print(root->right);
    }
}
```

å¦‚ä½•è§£å¼•ï¼Ÿ

* ä½¿ç”¨å‡½æ•°æŒ‡é’ˆ
  * `type (*func_name)(parameter_list)`

```c
void print_string(const void* value_ptr)
{
    char* string = value_ptr;//å¼ºè½¬void*æ³›æŒ‡é’ˆ
    printf("%s\n",string);
}

void print(node* root, void(* print_function)(const void*))
{
    if(root)
    {
        print_function(root->value_ptr);//å›è°ƒï¼Œå¼ºè½¬æˆchar*
        print(root->left, print_function);
        print(root->right, print_function);
    }
}

int main()
{
    node* root=;
    print(root, print_string);//æˆ–ä¼ å…¥&print_string
}

```

## å¿«æ’ä¾‹å­

```c
void qsort(void* ptr,size_t count, size_t size, int(*comp)(const void*, const void*));//å›è°ƒåœ¨compå‡½æ•°æŒ‡é’ˆä¸­å¼ºè½¬åï¼Œè§£å¼•æ¯”è¾ƒ

int compare(const void* first, const void* second)
{
    const float* f_first = first;
    const float* f_second = second;
    return *f_first - *f_second;
}
```

## Memory Management Challenges: æ‚¬ç©ºæŒ‡é’ˆ

æ¯æ¬¡è°ƒç”¨`malloc`ï¼Œéœ€è¦è´Ÿè´£é‡Šæ”¾å†…å­˜`free`

![](/static/2020-11-03-20-31-22.png)

* è‰¯å¥½å®è·µï¼šæŒ‡é’ˆæ‰€æŒ‡ç©ºé—´è¢«é‡Šæ”¾åï¼Œä½¿å…¶æŒ‡å‘`NULL/0`
  * assign the NULL value to pointers that have been freed
  * <font color="red">ä½†æ˜¯æ— æ³•é¿å… **all double freeé”™è¯¯**</font>

double free error

```c
int main()
{
    void* ptr1 = malloc(sizeof(int));
    void* ptr2 = ptr1;
    free(ptr1)
    ptr1=NULL;
    free(ptr1);//OK, free with NULL is fine
    free(ptr2);//error. pointer being freed was not allocated
    //ptr2 double free error?
}
```

æ‚¬ç©ºæŒ‡é’ˆ dangling pointers

```c
int main(){
    node* left = create_tree("a", NULL,NULL);
    node* root = create_tree("b", left, NULL);
    destroy_tree(left);//freeä¹‹åï¼Œroot->leftæŒ‡é’ˆæŒ‡å‘å·²è¢«é‡Šæ”¾çš„åœ°å€ï¼Œä¸ºé€‰ç©ºæŒ‡é’ˆ
}

```

### Memory Leak å†…å­˜æ³„æ¼

å¦‚æœå †å†…å­˜ä½¿ç”¨å®Œæ¯•åï¼Œä¸è°ƒç”¨`free`é‡Šæ”¾æŒ‡é’ˆ

* é€ æˆmemory leak

```c
int main()
{
    char* mem =(char*)malloc(sizeof(char)*20);
    if(!mem) exit(EXIT_FAILURE);//check if allocation went fine

    //use allocated memory
    mem = (char*) malloc(sizeof(char)*30);//allocate more memory without free previous one
    free(mem);
    //leak the memory allocated before
}

```

### å¦‚ä½•é¿å…é‡æŒ‡é’ˆ&é€‰ç©ºæŒ‡é’ˆ

é¿å…é‡æŒ‡é’ˆ

* å®šä¹‰æŒ‡é’ˆæ—¶å…»æˆä¹ æƒ¯
  * ä¸ç¡®å®šæ—¶åˆå§‹åŒ–ä¸º`NULL`

å¦‚ä½•é¿å…æ‚¬ç©ºæŒ‡é’ˆï¼Ÿ

![](/static/2020-11-03-20-38-39.png)

## Ownership: æ‰€æœ‰æƒ

ownershipæ‰€æœ‰æƒ

* identify a **single entity which is responsible for managing a location in memory**
  * è´Ÿè´£å†…å­˜ç®¡ç†çš„å®ä½“
  * å¦‚æ ‘ä¸­ï¼Œparentè´Ÿè´£åˆ†é…é‡Šæ”¾å­èŠ‚ç‚¹
* cä¸æ”¯æŒï¼Œä¸å¼ºåˆ¶ä½¿ç”¨æ‰€æœ‰æƒæ¨¡å‹
  * C++
  * RUSTï¼Œç¼–è¯‘å™¨å¼ºåˆ¶ã€‚é¿å…double free & dangling pointersé—®é¢˜ã€‚é¿å…ç»å¤§å¤šæ•°å†…å­˜æ³„æ¼é—®é¢˜

### Implementing RALL in C++

![](/static/2020-11-03-20-51-00.png)

c++ RALLæœºåˆ¶

* è¯¥æœºåˆ¶å¯ä»¥åº”ç”¨äº å†…å­˜ç®¡ç†ï¼Œèµ„æºç®¡ç†ï¼Œ...
* **èµ„æºç®¡ç† resource management**
  * files
  * network
  * database connections

[å‚è€ƒ](https://blog.csdn.net/yyxyong/article/details/76099721)

> resource acquisition is initialization çš„ç¼©å†™ï¼Œæ„ä¸ºâ€œèµ„æºè·å–å³åˆå§‹åŒ–â€

* **å¯¹è±¡çš„ææ„æ˜¯è‡ªåŠ¨å®Œæˆ**çš„ï¼Œé‚£ä¹ˆå¯ä¸å¯ä»¥åˆ©ç”¨è¿™ä¸ªæœºåˆ¶å‘¢
  * å°†èµ„æºæ‰˜ç®¡ç»™æŸä¸ªå¯¹è±¡ï¼Œæˆ–è€…è¯´è¿™ä¸ªå¯¹è±¡æ˜¯èµ„æºçš„ä»£ç†ï¼Œ**åœ¨è¿™ä¸ªå¯¹è±¡ææ„çš„æ—¶å€™å®Œæˆèµ„æºçš„é‡Šæ”¾**

c++ä¾‹å­

```cpp
typedef struct ints_on_heap{
    int* ptr;
    // constructor
    ints_on_heap(int size){
        ptr = (int*)malloc(sizeof(int)* size);
    }
    //ææ„destructor
    ~ints_on_heap()
    {
        free(ptr);
    }
}ints_on_heap;

int main(){
    ints_on_heap i(23);æ‹¬å·è°ƒç”¨
    i.ptr[22]=42;
}//ç»“æŸåï¼Œè‡ªåŠ¨è°ƒç”¨ææ„~é‡Šæ”¾å †å†…å­˜
```

### RALL: Resource management

![](/static/2020-11-04-01-45-57.png)

### Modern Memory Management C++

å¦‚è¦åœ¨å †ä¸­å­˜å‚¨å¤šä¸ªç›¸åŒç±»å‹æ•°æ®

![](/static/2020-11-04-01-50-12.png)

* ä½¿ç”¨`std::vector`
  * å°±æ˜¯ä¸ªlistå®¹å™¨
* **æ™ºèƒ½æŒ‡é’ˆ(å¤šçº¿ç¨‹)**
  * `std::unique_ptr`
    * unique ownership
    * ä¸€ä¸ªå¯¹è±¡èµ„æºï¼ˆå †ï¼‰åªèƒ½åŒæ—¶è¢«ä¸€ä¸ªunique_ptræŒ‡å‘
    * Unique ownership should be the default case where a single variable isÂ owningÂ the value on the heap
  * `std::share_ptr`
    * shared ownership
    * Shared ownership should be used in situations where it is not possible to identify a single owner
    * shared_ptrå…è®¸å¤šä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€ä¸ªå¯¹è±¡

```cpp
int main()
{
    std::vector<int> v={1,2,3,4,5};//heap memory is allocated for the numbers
}// memory on heap will be freed automatically
```

## C++11 æ™ºèƒ½æŒ‡é’ˆ

[å‚è€ƒ](https://www.cnblogs.com/leijiangtao/p/12046648.html)

> åœ¨C++ä¸­ï¼ŒåŠ¨æ€å†…å­˜çš„ç®¡ç†æ˜¯é€šè¿‡ä¸€å¯¹è¿ç®—ç¬¦æ¥å®Œæˆçš„ï¼š**newï¼Œ**åœ¨åŠ¨æ€å†…å­˜ä¸­ä¸ºå¯¹è±¡åˆ†é…ç©ºé—´å¹¶è¿”å›ä¸€ä¸ªæŒ‡å‘è¯¥å¯¹è±¡çš„æŒ‡é’ˆï¼Œå¯ä»¥é€‰æ‹©å¯¹å¯¹è±¡è¿›è¡Œåˆå§‹åŒ–ï¼›**delete**ï¼Œæ¥å—ä¸€ä¸ªåŠ¨æ€å¯¹è±¡çš„æŒ‡é’ˆï¼Œé”€æ¯è¯¥å¯¹è±¡ï¼Œå¹¶é‡Šæ”¾ä¸ä¹‹å…³è”çš„å†…å­˜ã€‚

* æœ‰æ—¶å€™ä¼šå¿˜è®°é‡Šæ”¾å†…å­˜ï¼Œå¯èƒ½ä¼šäº§ç”Ÿå†…å­˜æ³„æ¼ï¼Œæˆ–æ‚¬ç©ºæŒ‡é’ˆç­‰æƒ…å†µ
* **ä¸ºäº†æ›´å®‰å…¨ä½¿ç”¨åŠ¨æ€å†…å­˜ï¼Œæä¾›äº†æ™ºèƒ½æŒ‡é’ˆï¼Œç®¡ç†åŠ¨æ€å¯¹è±¡**
  * è´Ÿè´£è‡ªåŠ¨é‡Šæ”¾æ‰€æŒ‡å¯¹è±¡

ğŸŠ ä¸¤ä¸ªæ™ºèƒ½æŒ‡é’ˆåŒºåˆ«

* **ç®¡ç†åº•å±‚æŒ‡é’ˆæ–¹å¼ä¸åŒ**
* `shared_ptr`
  * å…è®¸å¤šä¸ªæŒ‡é’ˆæŒ‡å‘åŒä¸€å¯¹è±¡
* `unique_ptr`
  * ç‹¬å æ‰€æŒ‡å¯¹è±¡
* **C++11æ ‡å‡†åº“è¿˜æä¾›`weak_ptr`è¾…åŠ©ç±»**
  * æŒ‡å‘`shared_ptr`æ‰€ç®¡ç†çš„å¯¹è±¡
* æ™ºèƒ½æŒ‡é’ˆçš„ä½¿ç”¨è·ŸæŒ‡é’ˆç›¸åŒ
  * é»˜è®¤åˆå§‹åŒ–ä¿å­˜ä¸€ä¸ªç©ºæŒ‡é’ˆ

## äºŒå‰æ ‘ï¼šæ™ºèƒ½æŒ‡é’ˆä¾‹å­

```cpp
#include<memory>
struct node{
    const void* value ptr;
    //çˆ¶èŠ‚ç‚¹ç‹¬å å­èŠ‚ç‚¹
    std::unique_ptr<struct node> left;
    std::unique_ptr<struct node> right;
    struct node* parent;

    node(const void* value_ptr)
    {
        value_ptr=value_ptr;
        left = NULL;
        right = NULL;
        parent=NULL;
    }

    //ææ„
    ~node(){
    }

    void add_left(const void* value_ptr)
    {
        // make_unique ä¸ºnodeåˆ†é…å †å†…å­˜ &å¹¶ä¸”è°ƒç”¨nodeæ„é€ å‡½æ•°
        left = std::make_unique<node>(value_ptr);
    }

    void add_right(const void* value_ptr)
    {
        right = std::make_unique<node>(value_ptr);
    }
}
```

## Ownership transfer

![](/static/2020-11-04-02-25-58.png)

* å€¼ä¼ é€’ç»™å½¢å‚æ—¶ä¼šè°ƒç”¨æ‹·è´æ„é€ ï¼Œ
  * æ‰€ä»¥ç”¨`std::move`è½¬ç§»æ™ºèƒ½æŒ‡é’ˆæ‰€å å¯¹è±¡
  * **è½¬ç§»åï¼ŒæŒ‡é’ˆæŒ‡å‘ä¸ºç©ºï¼Œä¸èƒ½å†è®¿é—®**

